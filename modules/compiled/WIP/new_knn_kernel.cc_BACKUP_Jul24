
#if GOOGLE_CUDA
#define EIGEN_USE_GPU
#endif  // GOOGLE_CUDA


#include "tensorflow/core/framework/op_kernel.h"
#include "new_knn_kernel.h"
#include "helpers.h"
#include <string> //size_t, just for helper function
#include <cmath>

#include <iostream> //remove later DEBUG FIXME

using namespace std;

namespace tensorflow {
typedef Eigen::ThreadPoolDevice CPUDevice;
typedef Eigen::GpuDevice GPUDevice;

namespace functor {

void findNeighbours(const size_t* indices_of_vert_to_find_new_neigh,
                    const size_t n_vertices_to_loop, // size of the first input array
                    const size_t* n_verts_in_bins, 
                    const size_t n_bins,
                    const size_t indx_bin_to_use, // index of the newly added bin
                    const float *d_coord,
                    size_t n_coords,
                    size_t n_neigh,
                    float* d_dist,
                    int* d_indices,
                    float max_radius
                    ){

    // loop to assign indices and distances to other vertices
    size_t n_vert = 0;
    size_t start_vert = 0;
    size_t end_vert = 0;
    for (size_t i = 0; i < n_bins; i++){
        n_vert += n_verts_in_bins[i];
        if (i<indx_bin_to_use){
            start_vert += n_verts_in_bins[i];
        }
        if (i==indx_bin_to_use){
            end_vert = start_vert + n_verts_in_bins[i];
        }

    }

    for(size_t i = 0; i < n_vertices_to_loop; i++){
        size_t i_v = indices_of_vert_to_find_new_neigh[i];

        if(i_v>=n_vert)
            return;//this will be a problem with actual RS, just a safety net


        //protection against n_vert<n_neigh
        size_t nvert_in_row = n_vert;
        size_t max_neighbours = n_neigh;
        //set default to self
        if(nvert_in_row<n_neigh){
            max_neighbours=nvert_in_row;
        }


        size_t nfilled=0;
        int running_index = max_neighbours - 1;
        while (running_index>=0){
            if (d_indices[I2D(i_v,running_index,n_neigh)] == -1) // default init value
                running_index -= 1;
            else{
                nfilled = running_index+1;
                break;
            }
        }

        float maxdistsq = 0;
        size_t maxidx_local = 0;
        if (nfilled>0){
            maxidx_local = searchLargestDistance(i_v,d_dist,n_neigh,maxdistsq);
        }

        // assigning loop - searching neighbouth for i_v
        for(size_t j_v=start_vert;j_v<end_vert;j_v++){
            if(i_v == j_v)
                continue;
            //fill up
            float distsq = calculateDistance(i_v,j_v,d_coord,n_coords);
            if(nfilled<max_neighbours && (max_radius<=0 || max_radius>=distsq)){
                // filling in distances until we reach max_neighbours
                d_indices[I2D(i_v,nfilled,n_neigh)] = j_v;
                d_dist[I2D(i_v,nfilled,n_neigh)] = distsq;
                if(distsq > maxdistsq){
                    maxdistsq = distsq;
                    maxidx_local = nfilled;
                }
                nfilled++;
                continue;
            }
            // if we already filled max_neighbours distances, compare each new distance
            // with the current maximum. if distance is smaller - threw away current maximum,
            // fill in new distance and find new maximum
            if(distsq < maxdistsq){// automatically applies to max radius
                //replace former max
                d_indices[I2D(i_v,maxidx_local,n_neigh)] = j_v;
                d_dist[I2D(i_v,maxidx_local,n_neigh)] = distsq;
                //search new max
                maxidx_local = searchLargestDistance(i_v,d_dist,n_neigh,maxdistsq);
            }
        }// loop through vertices
    }// loop through vertices
}


float calculateDistance(size_t i_v, size_t j_v, const float * d_coord, size_t n_coords){
    float distsq=0;
    if(i_v == j_v)
        return 0;
    for(size_t i=0;i<n_coords;i++){
        float dist = d_coord[I2D(i_v,i,n_coords)] - d_coord[I2D(j_v,i,n_coords)];
        distsq += dist*dist;
    }
    return distsq;
}

int searchLargestDistance(int i_v, float* d_dist, int n_neigh, float& maxdist){

    maxdist=0;
    int maxidx=0;
    if(n_neigh < 2)
        return maxidx;
    // for(size_t n=1;n<n_neigh;n++){ //0 is self
    for(size_t n=0;n<n_neigh;n++){ // FIXME, otherwise it doesn't work
        float distsq = d_dist[I2D(i_v,n,n_neigh)];
        if(distsq > maxdist){
            maxdist = distsq;
            maxidx = n;
        }
    }
    return maxidx;
}

void set_defaults(
        int *d_indices,
        float *d_dist,
        const bool tf_compat,
        const int n_vert,
        const int n_neigh
){
    for(size_t i_v =0 ; i_v < n_vert ; i_v++){
        for(size_t n = 0; n < n_neigh; n++){

            if(n){
                if(tf_compat)
                    d_indices[I2D(i_v,n,n_neigh)] = i_v;
                else
                    d_indices[I2D(i_v,n,n_neigh)] = -1;
            }
            else{
                d_indices[I2D(i_v,n,n_neigh)] = i_v;
            }
            d_dist[I2D(i_v,n,n_neigh)] = 0;

        }
    }
}

struct BinnedCoords{ 
    // Usage example:
    //
    // float* binEdgesX = binEdges[0];
    // float* binEdgesY = binEdges[1];
    // size_t nBinX = n_bins[0];
    // size_t nBinY = n_bins[1];
    // size_t bin_index = I2D(iBinX, iBinY, nBinY);
    //
    // // iDim = 0..(n_coords-1)
    // d_coord_in_bins = coords[bin_index][I2D(iVertex,iDim,n_coords)]
    //

    float **coords; // *d_coord_in_bins[n_bins_x*n_bins_y]
    size_t n_coords; // iDim = 0..(n_coords-1)
    size_t *n_bins; // {n_bins_x, n_bins_y}
    size_t *counter; // nVertices = counter[I2D(iBinX, iBinY, nBinY)] 
    float **binEdges; 
}; 
  
void freeMemory(BinnedCoords &binnedCoords){
    for(size_t i=0; i<binnedCoords.n_bins[1]*binnedCoords.n_bins[2]; i++){
        delete[] binnedCoords.coords[i];
    }
    delete[] binnedCoords.binEdges[0];
    delete[] binnedCoords.binEdges[1];
    delete[] binnedCoords.binEdges;
    delete[] binnedCoords.coords;
    delete[] binnedCoords.n_bins;
    delete[] binnedCoords.counter;
}

// calculate min and max of X and Y coordinates among all vertices
// make bins with widths: (x_max-x_min)/n_bins and (y_max-y_min)/n_bins
void constructPhaseSpaceBins(size_t start_vert, size_t end_vert, size_t n_bins_x, size_t n_bins_y, const float *d_coord, size_t n_coords, BinnedCoords &out){

    out.n_coords = n_coords;
    out.coords = new float*[n_bins_x*n_bins_y];
    for(size_t i=0; i<n_bins_x*n_bins_y; i++){
        out.coords[i] = new float[n_coords*(end_vert-start_vert)];
    }
    out.counter = new size_t[n_bins_x*n_bins_y];
    for(int i=0; i<n_bins_x*n_bins_y; i++)
        out.counter[i] = 0;

    out.binEdges = new float*[2];
    out.binEdges[0] = new float[n_bins_x+1];
    out.binEdges[1] = new float[n_bins_y+1];

    out.n_bins = new size_t[2];
    out.n_bins[0] = n_bins_x;
    out.n_bins[1] = n_bins_y;

    const size_t n_coords_to_use = 2; // use only {x,y} coordinates

    // initialize min/max. take the first vertex to fill in an initial min/max values
    int i_v = 0; 
    float max[n_coords_to_use] = {d_coord[I2D(i_v,0,n_coords)], d_coord[I2D(i_v,1,n_coords)]};
    float min[n_coords_to_use] = {d_coord[I2D(i_v,0,n_coords)], d_coord[I2D(i_v,1,n_coords)]};


    // calculate min and max values for {X,Y} vertices coordinates
    for(size_t i_v = start_vert; i_v < end_vert; i_v ++){
        for(size_t iDim=0;iDim<n_coords_to_use;iDim++){
            float coord = d_coord[I2D(i_v,iDim,n_coords)];
            if (coord>max[iDim])
                max[iDim] = coord;
            if (coord<min[iDim])
                min[iDim] = coord;
        }
    }

    // define phase-space bin edges
    for(size_t iDim=0;iDim<n_coords_to_use;iDim++){
        for(size_t iBin=0; iBin<out.n_bins[iDim]; iBin++){
            out.binEdges[iDim][iBin] = min[iDim] + iBin*(max[iDim] - min[iDim])/out.n_bins[iDim];
        }
        out.binEdges[iDim][out.n_bins[iDim]] = max[iDim];
    }

    // define which vertices belong to which bin
    for(size_t i_v = start_vert; i_v < end_vert; i_v++){
        size_t indx[2] = {0,0};
        for(size_t iDim=0;iDim<n_coords_to_use;iDim++){
            float coord = d_coord[I2D(i_v,iDim,n_coords)];
            while (coord>out.binEdges[iDim][indx[iDim]+1]){
                indx[iDim] += 1;
            }
        }
        // copy all coordinates to new array which correspond to proper bin
        size_t bin_index = I2D(indx[0], indx[1], out.n_bins[1]);
        size_t n_filled_vertices = out.counter[bin_index];
        for(size_t iDim=0;iDim<n_coords;iDim++){
            out.coords[bin_index][I2D(n_filled_vertices,iDim,n_coords)] = d_coord[I2D(i_v,iDim,n_coords)];
        }
        out.counter[bin_index] += 1;
    }

    // DEBUG PRINTOUTS
    // cout << endl;
    // for (size_t iBinX=0; iBinX<n_bins_x; iBinX++){
    //     for (size_t iBinY=0; iBinY<n_bins_y; iBinY++){
    //         size_t bin_index = I2D(iBinX, iBinY, n_bins_y);
    //         cout << "nVertices: " << out.counter[bin_index] << std::endl;
    //         std::cout << "Bin: " << bin_index << "(" << iBinX << "," << iBinY << ");" << endl  \
    //             << " x: " << out.binEdges[0][iBinX] << " - " << out.binEdges[0][iBinX+1] << endl       \
    //             << " y: " << out.binEdges[1][iBinY] << " - " << out.binEdges[1][iBinY+1]               \
    //             << endl;
    //         for(size_t iDim=0;iDim<n_coords;iDim++){
    //             for(size_t iVertex=0; iVertex<out.counter[bin_index]; iVertex++){
    //                 std::cout << out.coords[bin_index][I2D(iVertex,iDim,n_coords)] << "\t";
    //             }
    //             std::cout << std::endl;
    //         }
    //         std::cout << std::endl;
    //     }
    // }
}

float calculateDistanceToThePoint(float pointCoord, size_t i_v, const float* d_coord, size_t n_coords){
    float distsq=0;
    for(size_t i=0;i<n_coords;i++){
        float dist = d_coord[I2D(i_v,i,n_coords)] - pointCoord[i];
        distsq += dist*dist;
    }
    return sqrt(distsq);
}

void calculate2dDistanceToTheBinEdges(size_t i_v, size_t current_bin_x, size_t current_bin_y, BinnedCoords binnedCoords, float& distances){

    size_t current_bin_indices[2] = {current_bin_x, current_bin_y};
    size_t n_bins_x = binnedCoords.n_bins[0];
    size_t n_bins_y = binnedCoords.n_bins[1];
    size_t current_bin_index = I2D(current_bin_x, current_bin_y, n_bins_y);
    float* d_coord_in_bin = binnedCoords.coords[bin_index];

    size_t n_coords = binnedCoords.n_coords;

    distances = new float[n_bins_x*n_bins_y];
    for(int i=0; i<n_bins_x*n_bins_y; i++)
        distances[i] = std::numeric_limits<float>::max();

    int selected_bin_index = -1;
    for(size_t i_bin_x=0; i_bin_x<n_bins_x){ 
        for(size_t i_bin_y=0; i_bin_y<n_bins_y){
            selected_bin_index = I2D(i_bin_x, i_bin_y, n_bins_y);
            if (current_bin_index == selected_bin_index)
                continue;
            if ((current_bin_x==i_bin_x) || (current_bin_y==i_bin_y)){
                size_t iDim = 0;
                size_t i_bin = i_bin_x;
                if (current_bin_y==i_bin_y){
                    iDim = 1;
                    i_bin = i_bin_y;
                }
                float lowBinEdge = binnedCoords.binEdges[iDim][i_bin];
                float highBinEdge = binnedCoords.binEdges[iDim][i_bin+1];
                float d1 = abs(d_coord_in_bin[I2D(i_v,iDim,n_coords)] - lowBinEdge);
                float d2 = abs(d_coord_in_bin[I2D(i_v,iDim,n_coords)] - highBinEdge);
                distances[selected_bin_index] = (d1<d2) ? d1 : d2;
            }
            else{ // diagonal bin
                float bin_coord_x = binnedCoords.binEdges[0][i_bin_x]; // left side
                float bin_coord_y = binnedCoords.binEdges[1][i_bin_y]; // bottom side
                if (i_bin_x<current_bin_x)
                    bin_coord_x = binnedCoords.binEdges[0][i_bin_x+1]; // right side
                if (i_bin_y<current_bin_y)
                    bin_coord_y = binnedCoords.binEdges[1][i_bin_y+1]; // top side
                float pointCoord[2] = {bin_coord_x, bin_coord_y};
                distances[selected_bin_index] = calculateDistanceToThePoint(pointCoord, i_v, d_coord_in_bin, 2);
            }
        }
    }

    return;
}


void new_knn_kernel(
        const float *d_coord,
        const int* d_row_splits,
        int *d_indices,
        float *d_dist,

        const int n_vert,
        const int n_neigh,
        const int n_coords,

        const int j_rs,
        const bool tf_compat,
        const float max_radius) {

    //really no buffering at all here

    const size_t start_vert = d_row_splits[j_rs];
    const size_t end_vert = d_row_splits[j_rs+1];

    size_t n_bins_x = 2;
    size_t n_bins_y = 2;
    BinnedCoords binnedCoords;
    constructPhaseSpaceBins(start_vert, end_vert, n_bins_x, n_bins_y, d_coord, n_coords, binnedCoords);


    float* binEdgesX = binnedCoords.binEdges[0];
    float* binEdgesY = binnedCoords.binEdges[1];
    n_bins_x = binnedCoords.n_bins[0];
    n_bins_y = binnedCoords.n_bins[1];

    // DEBUG PRINTOUT
    for (size_t iBinX=0; iBinX<n_bins_x; iBinX++){
        for (size_t iBinY=0; iBinY<n_bins_y; iBinY++){
            cout << endl;
            size_t bin_index = I2D(iBinX, iBinY, n_bins_y);
            float* d_coord_in_bin = binnedCoords.coords[bin_index];
            size_t n_vert_in_bin = binnedCoords.counter[I2D(iBinX, iBinY, n_bins_y)];
            cout << "Bin: " << bin_index << "(" << iBinX << "," << iBinY << "); nVert: " << n_vert_in_bin << endl;
            cout << "Bin Edges. X: " << binEdgesX[iBinX] << "-" << binEdgesX[iBinX+1] << "; Y: " << binEdgesY[iBinY] << "-" << binEdgesY[iBinY+1] << endl;
            for(size_t iVert=0; iVert<n_vert_in_bin; iVert++){
                cout << "Vertex: " << iVert << endl;
                for(size_t iDim=0; iDim<n_coords; iDim++){
                    float coord = d_coord_in_bin[I2D(iVert,iDim,n_coords)];
                    cout << coord << " ";
                }
                cout << endl;
            }
        }
    }// DEBUG PRINTOUT


    findNeighbours(const size_* indices_of_vert_to_find_new_neigh,
                   const size_t n_vertices_to_loop, // size of the first input array
                   const size_t* n_verts_in_bins, 
                   const size_t n_bins,
                   const size_t indx_bin_to_use, // index of the newly added bin
                   const float *d_coord,
                   size_t n_coords,
                   size_t n_neigh,
                   float& d_dist,
                   int& d_indices,
                   size_t n_neigh_before // size of filled
                   );




    // WIP after this comment
    float* distances = NULL;
    calculate2dDistanceToTheBinEdges(size_t i_v, size_t current_bin_x, size_t current_bin_y, binnedCoords, distances);

    // free allocated memory
    freeMemory(binnedCoords);
    delete[] distances;

}

// CPU specialization
template<typename dummy>
struct NewKnnOpFunctor<CPUDevice, dummy> {
    void operator()(const CPUDevice &d,

            const float *d_coord,
            const int* d_row_splits,
            int *d_indices,
            float *d_dist,

            const int n_vert,
            const int n_neigh,
            const int n_coords,

            const int n_rs,
            const bool tf_compat,
            const float max_radius) {


        // set_defaults(d_indices,
        //         d_dist,
        //         tf_compat,
        //         n_vert,
        //         n_neigh);
        //really no buffering at all here

        for(size_t j_rs=0;j_rs<n_rs-1;j_rs++){
            new_knn_kernel(d_coord,
                    d_row_splits,
                    d_indices,
                    d_dist,

                    n_vert,
                    n_neigh,
                    n_coords,

                    j_rs,
                    tf_compat,
                    max_radius);
        }
    }
};

template<typename Device>
class NewKnnOp : public OpKernel {
public:
    explicit NewKnnOp(OpKernelConstruction *context) : OpKernel(context) {
        OP_REQUIRES_OK(context,
                        context->GetAttr("n_neighbours", &K_));
        OP_REQUIRES_OK(context,
                        context->GetAttr("tf_compatible", &tf_compat_));
        OP_REQUIRES_OK(context,
                        context->GetAttr("max_radius", &max_radius_));

        if(max_radius_>0)
            max_radius_ *= max_radius_;//use squared

    }

    void Compute(OpKernelContext *context) override {

        const Tensor &d_coord_tensor = context->input(0);
        const Tensor &d_rs_tensor = context->input(1);


        int n_vert = d_coord_tensor.dim_size(0);
        int n_coords = d_coord_tensor.dim_size(1);
        int n_rs = d_rs_tensor.dim_size(0);

        TensorShape outputShape;
        outputShape.AddDim(n_vert);
        outputShape.AddDim(K_);

        Tensor *output_tensor = NULL;
        OP_REQUIRES_OK(context, context->allocate_output(0, outputShape, &output_tensor));

        Tensor *output_distances = NULL;
        OP_REQUIRES_OK(context, context->allocate_output(1, outputShape, &output_distances));


        NewKnnOpFunctor<Device, int>()(
                context->eigen_device<Device>(),

                d_coord_tensor.flat<float>().data(),
                d_rs_tensor.flat<int>().data(),
                output_tensor->flat<int>().data(),
                output_distances->flat<float>().data(),

                n_vert,
                K_,
                n_coords,

                n_rs,
                tf_compat_,
                max_radius_
        );



    }

private:
    int K_;
    bool tf_compat_;
    float max_radius_;
};

REGISTER_KERNEL_BUILDER(Name("NewKnn").Device(DEVICE_CPU), NewKnnOp<CPUDevice>);

#ifdef GOOGLE_CUDA
extern template struct NewKnnOpFunctor<GPUDevice, int>;
REGISTER_KERNEL_BUILDER(Name("NewKnn").Device(DEVICE_GPU), NewKnnOp<GPUDevice>);
#endif  // GOOGLE_CUDA

}//functor
}//tensorflow
